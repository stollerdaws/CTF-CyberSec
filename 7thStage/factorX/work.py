from sympy import mod_inverse

# Provided factors of n (converted to integers)
factors = [
    9932009287735560419, 10367113298848377293, 10419304089996284753, 10488866305655868941,
    11042003347154387689, 11220547316141825773, 11256057488134113383, 11332397604855387331,
    11335937594025053593, 14470158415367908037, 14550104339402611883, 15194149756122102631,
    15476095524715848523, 15986996778717226637, 16071599977799098877, 16865827052747656003,
    17154616813521041213
]
n=7419618182723656961164312531804655091408466591860316395533451485169499431221056805221162934649721406299753754288670380281913227214051073858096680056635846746210231488628067113981139548658791204821949014339952380244491297781045906117073878030056810274684785505423345073825764725497045282733147863478203970314849904714173494359

# Calculating phi(n)
phi_n = 1
for p in factors:
    phi_n *= (p - 1)

# Given e
e = 65537

# Calculating the private exponent d
d = mod_inverse(e, phi_n)

# Given ciphertext
ct = 2995976243037685395064606311029009971962671076510387580666319275160012706463240667475768742738198275145073662161944235426260144467916329170457396726653105721425100764361540993352300658395648932935771448714188761006970277805563475504533020991644198136103578397865333071241644374831136433061131226606583064805893344791920954332

# Decrypting the ciphertext
plaintext = pow(ct, d, n)

def int_to_text(number):
    """ Converts a large integer to a string assuming ASCII encoding """
    text = ""
    while number > 0:
        number, ascii_val = divmod(number, 256)
        text = chr(ascii_val) + text
    return text

# Converting the decrypted plaintext to text
decrypted_text = int_to_text(plaintext)
print(decrypted_text)