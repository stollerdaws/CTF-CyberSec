from Crypto.Util.number import inverse, long_to_bytes

# Given values
p = 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842077
q = 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842083
r = 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842089
e = 2**16 + 1
ct = 9953835612864168958493881125012168733523409382351354854632430461608351532481509658102591265243759698363517384998445400450605072899351246319609602750009384658165461577933077010367041079697256427873608015844538854795998933587082438951814536702595878846142644494615211280580559681850168231137824062612646010487818329823551577905707110039178482377985

# Calculate n and phi(n)
n = p * q * r
phi_n = (p - 1) * (q - 1) * (r - 1)

# Calculate d, the modular multiplicative inverse of e modulo phi(n)
d = inverse(e, phi_n)

# Decrypt the ciphertext
pt_long = pow(ct, d, n)
FLAG = long_to_bytes(pt_long)

print("Decrypted FLAG:", FLAG.decode())
